#!/usr/bin/perl
#
# Generates the SQL file for a specific RDBMS.
# This file is part of http://github/m5n/nutriana


# Change these to suit your needs.
# TODO: move to properties file
my $DB_NAME = "food";
my $DB_SERVER = "localhost";
my $DB_USER = "food";
my $DB_PWD = "food";


use strict;
use JSON;


my $dbid = $ARGV[0];
my $nutdbid = $ARGV[1];
die "Usage: $0 rdbmsid nutdbid\n" if !$dbid or !$nutdbid;


my $project_url = "http://github.com/m5n/nutriana";
my $pwd = `pwd`; chomp $pwd;
my $file = "$pwd/$nutdbid/schema.json";
my $json = do { local $/ = undef; open my $fh, "<", $file or die "Could not open $file: $!"; <$fh>; };
my $data = decode_json($json);
my $field_separator = $data->{"field_separator"};
my $text_separator = $data->{"text_separator"};
my $header = $data->{"description"} . " (" . $data->{"url"} . ")";
my $header_length = length($header);


# Output header.
print sql_comment("="x$header_length). "\n";
print sql_comment($header) . "\n";
print sql_comment("This file was generated by $project_url") . "\n";
print sql_comment("Run this SQL with an account that has admin priviledges, e.g.: " . sql_how_to_run_as_admin()) . "\n";
print sql_comment("="x$header_length). "\n\n";


# Set up database.
print sql_drop_database($DB_NAME) . "\n";
print sql_create_database($DB_NAME) . "\n";
print sql_use_database($DB_NAME) . "\n\n";


# Set up user.
print sql_drop_user($DB_USER, $DB_SERVER) . "\n";
print sql_create_user($DB_USER, $DB_PWD, $DB_NAME, $DB_SERVER) . "\n\n";


# Set up tables.
# All tables must be defined before we can add foreign keys.
# To avoid having to figure out which tables should have their data loaded before other tables, load all data before adding foreign keys.
# Some databases can only import data fast if there are no constraints or triggers yet (e.g. Oracle), so load data before adding primary or foreign keys.
# Some databases support only case sensitive constraints (e.g. Oracle) and not all nutrient databases specify values with consistent casing (e.g. usda_nndsr), so do case conversion before adding primary or foreign keys.  (And because of the above, we cannot use triggers for this.)
# Some databases do not interpret empty string as null (e.g. MySQL) and some nutrient databases use empty string in nullable columns (e.g. usda_nndsr) causing problems with foreign keys, so convert empty strings to null to avoid the errors.
# So:
# 1. create tables
# 2. import data
# 3. fix casing and empty string issues
# 4. add primary keys
# 5. add foreign keys

# Create tables.
foreach (@{$data->{"tables"}}) {
    my %table = %{$_};
    my $table_name = substr($table{"file"}, 0, -length(".txt"));
    my @fields = @{$table{"fields"}};
    my $idx = 0;

    print sql_comment($table{"description"}) . "\n";
    print sql_create_table_start($table_name) . "\n";
    foreach (@fields) {
        my %field = %{$_};
        my $datatype = sql_datatype_def($field{"type"}, $field{"size"}, 1);
        print "    " . sql_field_def($field{"name"}, $datatype, $field{"allows_null"});
        print "," if $idx != $#fields;
        print "   " . sql_comment($field{"description"}) . "\n";
        $idx++;
    }
    print sql_create_table_end() . "\n\n";
}

# Import data.
foreach (@{$data->{"tables"}}) {
    my %table = %{$_};
    my $table_name = substr($table{"file"}, 0, -length(".txt"));
    my @fields = ();
    my @sizeparts;
    my $size;
    my $maxsize = 0;

    foreach (@{$table{"fields"}}) {
        my %field = %{$_};
        push @fields, $field{"name"};

        $size = 0;
        @sizeparts = split /\./, $field{"size"};
        foreach (@sizeparts) {
            $size += $_;
        }
        $size += $#sizeparts;   # Using maxindex here, so adding 0 if there's just 1 part.
        $maxsize = $size if $size > $maxsize;
    }

    print sql_comment("Load data into $table_name") . "\n";
    print sql_load_file($nutdbid, $DB_USER, $DB_PWD, "./$nutdbid/data/" . $table{"file"}, $table_name, $field_separator, $text_separator, $maxsize, @fields) . "\n";

    # Assert all records were loaded.  Make sure a SQL error is generated if the count is off.
    print sql_comment("Assert all " . $table{"records"} . " records were loaded") . "\n";
    print sql_assert_record_count($table_name, $table{"records"}) . "\n\n";
}

# Fix casing and empty string issues.
print sql_comment("Correct data inconsistencies") . "\n";
foreach (@{$data->{"tables"}}) {
    my %table = %{$_};
    my $table_name = substr($table{"file"}, 0, -length(".txt"));

    foreach (@{$table{"fields"}}) {
        my %field = %{$_};

        print sql_convert_to_uppercase($table_name, $field{"name"}) . "\n" if $field{"convert_to_uppercase"};
        print sql_convert_empty_string_to_null($table_name, $field{"name"}) . "\n" if $field{"convert_empty_string_to_null"};
    }
}
print "\n";

# Add primary keys.
print sql_comment("Add primary keys") . "\n";
foreach (@{$data->{"tables"}}) {
    my %table = %{$_};
    my $table_name = substr($table{"file"}, 0, -length(".txt"));
    my @primary_keys = ();

    foreach (@{$table{"fields"}}) {
        my %field = %{$_};

        push @primary_keys, $field{"name"} if $field{"is_primary_key"};
    }

    print sql_add_primary_keys($table_name, @primary_keys) . "\n" if $#primary_keys >= 0;
}
print "\n";

# Add foreign keys.
print sql_comment("Add foreign keys") . "\n";
foreach (@{$data->{"tables"}}) {
    my %table = %{$_};
    my $table_name = substr($table{"file"}, 0, -length(".txt"));

    foreach (@{$table{"fields"}}) {
        my %field = %{$_};

        print sql_add_foreign_key($table_name, $field{"name"}, $field{"foreign_key"}) . "\n" if $field{"foreign_key"};
    }
}

